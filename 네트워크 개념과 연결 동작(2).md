![image](https://github.com/xodbs1123/Network/assets/61976898/a6118c03-75c5-45a9-acce-b6614b2a6865)## DNS 동작 방식 ##
- 재귀적 쿼리(Recusive Query) + 반복적 쿼리(Iterative Query)

![image](https://github.com/xodbs1123/Network/assets/61976898/a899e9ce-9679-4cb8-a22d-9ad0c2df23e9)

## DNS 주요 레코드 ##
https://www.cloudflare.com/ko-kr/learning/dns/dns-records/
- **A       IPv4 호스트   도메인 주소를 IP 주소(IPv4)로 매핑**
- AAAA    IPv6호스트    도메인 주소를 IP 주소(Ipv6)로 매핑
- **CNAME   별칭**

![image](https://github.com/xodbs1123/Network/assets/61976898/0703e21e-b687-4738-8f95-e1413abcb665)

## DHCP(Dynamic Host Configuration Protocol) 서버 ##
- 호스트 IP 구성 관리를 단순화하는 IP 표준
- IP 주소 및 관련된 기타 구성 세부 정보를 네트워크의 DHCP 클라이언트에게 동적으로 할당하는 방법을 제공 (Subnet mask, Gateway IP 주소, DNS 서버 IP 주소 등)
- 정적 할당 => 수동으로 설정
- 동적 할당 => 자동으로 설정 = DHCP 이용
- 사용자 이동이 많고 한정된 IP 주소를 가진 경우 유용
- 서비스 포트 : 서버 67(bootps), 클라이언트68(bootpc)  

## DHCP 동작(4단계) ##

![image](https://github.com/xodbs1123/Network/assets/61976898/53507448-29fe-4e77-b96a-9b77826a8fd7)

## DHCP 갱신 ##

![image](https://github.com/xodbs1123/Network/assets/61976898/ebea6e25-471e-45c8-9812-d5379513e505)

## 물리적 주소 = MAC Address(Media Access Control Address) ##
- BIA(Burned-In Address) => LAN 카드에 새겨진 주소
- 네트워크 인터페이스에 할당된 고유 식별자
- 48bit => OUI(Organizationally Unique Identifier, 24bit) + UAA(Universally Administered Address, 24bit)
- OUI = IEEE가 제조사에 할당
   https://standards-oui.ieee.org/
- UAA = 각 제조사에서 할당 
- **LAN 영역에서 내부 통신을 수행하기 위해 필요한 주소**

## MAC 주소 동작 ##
![image](https://github.com/xodbs1123/Network/assets/61976898/f3ea4325-b21c-430f-aa29-e5c189f194b6)

## 무차별 모드(Promiscuous Mode) ##
- 기본적으로 NIC은 패킷의 목적지 MAC 주소가 자신의 MAC 주소와 다르면 폐기
- 무차별 모드로 NIC을 구성하면 자신의 MAC 주소와 상관없이 패킷이 들어오면 이를 분석할 수 있도록 메모리에 올려 처리할 수 있게 함
- 네트워크의 상태를 모니터링하거나 디버깅, 분석 용도로 네트워크 전체 패킷을 수집할 때 사용

## IP 주소 vs MAC 주소 ##
- IP 주소, 32bit, 네트워크 ID + 호스트 ID, IP 주소 기반의 라우팅
- MAC 주소, 48bit, OUI(24bit) + UAA(24bit), MAC 주소 기반의 스위칭

## ARP(Address Resolution Protocol, 주소 결정 프로토콜) ##
- 네트워크 상에서 IP 주소를 물리적 네트워크 주소(MAC)로 대응시키기 위해 사용하는 프로토콜
- 상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜
- 데이터 통신을 하기 위해 2계층 물리적 주소인 MAC 주소와 3계층 논리적 IP 주소 두 개를 사용
  - IP 주소와 MAC 주소를 연결해 주는 것 => ARP가 담당

## ARP 헤더 ##
![image](https://github.com/xodbs1123/Network/assets/61976898/c8da1bf6-b1ec-4bc7-a499-e5957439b1d7)

3) MAC 주소 길이 = 6
4) IP 주소 길이 = 4
5) ARP의 구체적인 동작
   - ARP Request
   - ARP Reply
   - RARP Request
   - RARP Reply
6) 7) 송신자의 MAC 주소와 IP 주소
8) 9) 수신자의 MAC 주소와 IP 주소 
ARP Request 동작 시 0으로 설정하고, 이더넷 헤더의 목적지 주소로 ff-ff-ff-ff-ff-ff로 설정(브로드 캐스팅)

## ARP 동작 ##
1) 목적지 MAC 주소를 모르기 때문에 정상적으로 패킷을 만들 수 없음

![image](https://github.com/xodbs1123/Network/assets/61976898/d1033e0f-439d-4149-b35e-aed94c3366a3)

2) ARP 요청(request)을 네트워크에 브로드캐스트

![image](https://github.com/xodbs1123/Network/assets/61976898/6bd174ae-6fc6-4fdb-aab0-a3f7259d68ed)

3) ARP 요청에 있는 대상자 IP 주소가 자신의 IP와 동일한 경우, 출발지로 ARP 응답(reply)을 유니케스트

![image](https://github.com/xodbs1123/Network/assets/61976898/ce3f7afa-15fa-4541-9d9f-8ea3d7a99873)

4) ARP 캐시 테이블 갱신 후 패킷을 생성해 전송

![image](https://github.com/xodbs1123/Network/assets/61976898/73c32779-c68c-4d08-84f6-38a73afbd27a)

## ARP 캐시 테이블 ##
- 패킷 네트워크에서는 큰 데이터를 잘라서 전송하므로 여러 개의 패킷을 전송해야 함
- 패킷을 보낼 때마다 ARP 프로드캐스트를 수행하면 네트워크 통신의 효율성이 크게 저하되므로 **메모리에 정보를 저장해두고 재사용**함

## Win7 가상머신에서 관리자 권한으로 명령 프롬프트 실행 ##
- arp -d    => ARP 캐시 테이블 삭제
- arp -a    => ARP 캐시 테이블 조회
- **ping 8.8.8.8 이후 캐시 테이블 조회**

![image](https://github.com/xodbs1123/Network/assets/61976898/64536521-acdb-4e7c-9640-454281575069)

- 10.2.2.2는 기본 게이트웨이의 MAC 주소 ( Ipconfig를 통해 확인 가능 )
  - 8.8.8.8은 내 PC의 로컬 영역이 아니므로 Gateway를 통해 접속
  - 이후 ARP 동작을 통해 캐시 테이블에 저장

  ## ping 8.8.8.8 동작 과정 ##
  1) 출발지 IP와 목적지 IP의 네트워크 ID를 비교
     - IPv4 Address   10.0.2.15(출발지)      8.8.8.8(목적지) 
     - Subnet Mask    255.255.255.0(출발지)  255.255.255.0(목적지)
     - Network ID     10.0.2(출발지)         8.8.8(목적지)
     => 출발지의 서브넷 마스크를 적용
     => 두 개의 네트워크 ID가 서로 다름
     => 목적지 주소를 게이트웨이 주소로 변경

  2) 게이트웨이의 MAC 주소 확인을 위해서 ARP Query를 브로드캐스팅 <= 수진처 미정 (목적지 MAC이 미설정)
     - IP    10.0.2.15(출발지)          10.0.2.2(목적지)
     - MAC   08-00-27-E8-33-3D(출발지)  00-00-00-00-00-00(목적지)

  3) 게이트웨이가 자신의 MAC 주소를 유니케스팅 <= 수신처를 지정해서 전달
     - IP    10.0.2.2(출발지)          10.0.2.15(목적지)
     - MAC  52-54-00-12-35-02(출발지)  08-00-27-E8-33-3D(목적지)

  4) 응답을 받은 출발지 호스트는 자신의 ARP 캐시 테이블에 반영
     - arp -a

  5) 이후부터는 게이트웨이 통신하기 위해서는 로컬 ARP 테이블에 MAC 주소를 이용해서 유니캐스팅
     - IP 			10.0.2.15(출발지)		      10.0.2.2(목적지)
     - MAC			08-00-27-E8-33-3D(출발지)	52-54-00-12-35-02(목적지)
    

## ARP 영역 ##
- ARP 요청과 응답이 일어나는 영역
- LAN 영역 = **동일한 네트워크 ID**를 공유하는 호스트가 **MAC 주소를 기반**으로 **스위칭 방식으로 내부 통신**을 수행하면서, **단일 ARP 영역을 생성**하는 공간

## 네트워크에서 출발지 -> 목적지로 데이터 전송할 때 사용하는 통신 방식 ##
![image](https://github.com/xodbs1123/Network/assets/61976898/3f9a3a9a-6e51-4455-bf46-35c5ad75182d)

## VM Window와 Kali Linux NAT Network 설정 ##

![image](https://github.com/xodbs1123/Network/assets/61976898/ba2e7acd-22d0-4f77-a460-b291b34622e0)

Win7 : 10.0.2.15
Kali : 10.0.2.4
- win7에서 kali로 핑 가는 모습
![image](https://github.com/xodbs1123/Network/assets/61976898/f492c9c7-f548-41b8-96a4-9b2efff84fa5)

- **Win7 가상머신에서 C:\SecureCoding\start_securecoding.bat 를 실행 ⇒ 웹 어플리케이션을 실행하기 위한 환경을 구성**

![image](https://github.com/xodbs1123/Network/assets/61976898/e27aff3a-9b8a-4aa6-9530-f973835c70db)

- **Kali 가상머신에서 브라우저를 실행한 후 http://WIN7_IP주소:8080/openeg 주소로 접근**

![image](https://github.com/xodbs1123/Network/assets/61976898/130b6d85-199c-43dc-8cd8-83dce5a4a8f0)

## 포트 포워딩으로 HOST -> VM 웹 애플리케이션 접속 ##

- Port Fowarding 설정

![image](https://github.com/xodbs1123/Network/assets/61976898/3d09d3d6-2604-41d0-947a-101615975786)

- Host PC에서 접속 되는 모습
  
![image](https://github.com/xodbs1123/Network/assets/61976898/52240712-5b3c-4daa-9458-40710579db80)

## 계층(Layer) ##
- 비음성 통신에서 데이터를 전송하기 위한 일련의 단계, 과정, 절차
- 송신자 운영체제가 응용 계층에서 시작해 전송, 네트워크, 데이터 링크 계층 순으로 데이터를 전송
- 수신자 운영체제가 역으로 물리 계층에서 시작해 데이터 링크, 네트워크, 응용 계층 순으로 데이터를 수신
<br><br>
응용 <-> 전송 <-> 네트워크 <-> 데이터링크 <-> 물리<br><br>
논리적이고 추상적        >>>    물리적이고 구체적 (헤더를 추가하는 과정, 인캡슐레이션 = 캡슐화)
